# Greenfield Bundle Service

## Overview

Greenfield Bundle Service is a service that allows users to upload small files to Greenfield in a more efficient way. 
It is designed to bundle small files together before uploading. This service will reduce storage space and costs caused
by small files while increasing the capacity of the entire network. It will also reduce the cost of uploading files to
Greenfield for users.

For bundle format information, please refer to [BEP-323](https://github.com/bnb-chain/BEPs/pull/323).

For go sdk of bundle format, please refer to [go-bundle](https://github.com/bnb-chain/greenfield-bundle-sdk).

## Architecture

The bundle service is composed of two parts: bundle service server and bundler:

* Bundle service server: a service that provides bundle service API for users to upload and download files in bundles.
  It also provides APIs for user to create and manage bundles manually like creating bundle, finalizing bundle and update
  bundle rules.
* Bundler: a service that bundles small files together before uploading to Greenfield and uploads the bundle to Greenfield.

// todo: add architecture picture when bundler is ready

## Build

### Build bundle service server

```shell
$ make build-server
```

## Bundle Service Server API 

The Bundle Service Server API provides several endpoints for managing and interacting with bundles. Here's a brief overview:

1. **Upload a single object to a bundle (`POST /uploadObject`):** This endpoint allows users to uploads a single object to a bundle, requiring details like bucket name, file name, and etc.

2. **Retrieve an object as a file from a bundle (`GET /view/{bucketName}/{bundleName}/{objectName}`):** This endpoint fetches a specific object from a given bundle and returns it as a file.

3. **Download an object as a file from a bundle (`GET /download/{bucketName}/{bundleName}/{objectName}`):** This endpoint allows users to download a specific object from a given bundle and returns it as a file.

4. **Start a New Bundle (`POST /createBundle`):** This endpoint initiates a new bundle, requiring details like bucket name and bundle name.

5. **Finalize an Existing Bundle (`POST /finalizeBundle`):** This endpoint completes the lifecycle of an existing bundle created by user, requiring the bundle name for authorization.

6. **Get Bundler Account for a User (`POST /bundlerAccount/{userAddress}`):** This endpoint returns the bundler account for a given user.

7. **Set New Bundling Rules (`POST /setBundleRule`):** This endpoint allows users to set new rules or replace old rules for bundling, including constraints like maximum size and number of files.

For more detailed information about each endpoint, including required parameters and response formats, please refer to the `swagger.yaml` file.

### Authorization

The `### Authorization` section of the `README.md` file can be filled as follows:

### Authorization

The Bundle Service Server API uses digital signatures for authorization. The user's digital signature is required for 
certain API endpoints to authenticate the user and authorize the operation.

The digital signature is passed in the `Authorization` header of the HTTP request. The signature is generated by signing 
a specific message derived from the request with the user's private key. The message to sign is generated by 
the `GetMsgToSignInBundleAuth`, `TextHash` functions in the `http.go` file which you can refer to.

The server verifies the signature using the `VerifySignature` function, also in the `http.go` file. This function 
recovers the signer's address from the signature and compares it with the expected address. If the addresses match, 
the signature is verified and the request is authorized.

Here is an example of how to generate the signature in Go:

```go
import (
    "github.com/ethereum/go-ethereum/crypto"
    "github.com/node-real/greenfield-bundle-service/types"
)

// Assume `req` is the http.Request to be sent
messageToSign := types.GetMsgToSignInBundleAuth(req)
messageHash := TextHash(messageToSign)

signature, err := crypto.Sign(messageHash, privateKey) // privateKey is the user's private key
if err != nil {
    // handle error
}

// Add the signature to the Authorization header
req.Header.Add("Authorization", hex.EncodeToString(signature))
```

Please replace `privateKey` with the actual private key. 
