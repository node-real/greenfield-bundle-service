package handlers

import (
	"encoding/json"
	"fmt"
	"io"
	"os"

	sdk "github.com/bnb-chain/greenfield-bundle-sdk/bundle"
	"github.com/ethereum/go-ethereum/common"
	"github.com/go-openapi/runtime/middleware"

	"github.com/node-real/greenfield-bundle-service/database"
	"github.com/node-real/greenfield-bundle-service/models"
	"github.com/node-real/greenfield-bundle-service/restapi/operations/bundle"
	"github.com/node-real/greenfield-bundle-service/service"
	"github.com/node-real/greenfield-bundle-service/types"
	"github.com/node-real/greenfield-bundle-service/util"
)

// HandleDeleteBundle handles delete bundle request
func HandleDeleteBundle() func(params bundle.DeleteBundleParams) middleware.Responder {
	return func(params bundle.DeleteBundleParams) middleware.Responder {
		// validate headers
		signerAddress, merr := types.ValidateHeaders(params.HTTPRequest)
		if merr != nil {
			util.Logger.Errorf("sig check error, code=%d, msg=%s", merr.Code, merr.Message)
			return bundle.NewCreateBundleBadRequest().WithPayload(merr)
		}

		// check bundle name prefix
		if service.IsAutoGeneratedBundleName(params.XBundleName) {
			util.Logger.Errorf("bundle name should not start with %s", service.BundleNamePrefix)
			return bundle.NewDeleteBundleBadRequest().WithPayload(types.ErrorInvalidBundleName)
		}

		// check existence and status of the bundle
		queriedBundle, err := service.BundleSvc.QueryBundle(params.XBundleBucketName, params.XBundleName)
		if err != nil {
			util.Logger.Errorf("query bundle error, bucket=%s, bundle=%s, err=%s", params.XBundleBucketName, params.XBundleName, err.Error())
			return bundle.NewDeleteBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}
		if queriedBundle == nil {
			return bundle.NewDeleteBundleBadRequest().WithPayload(types.ErrorBundleNotExist)
		}

		// check bundle status, can not delete finalized bundle
		if queriedBundle.Status == database.BundleStatusFinalized {
			return bundle.NewDeleteBundleBadRequest().WithPayload(types.ErrorInvalidBundleStatus)
		}

		// check if the signer is the owner of the bundle
		bucketInfo, err := service.BundleSvc.QueryBucketFromGnfd(params.XBundleBucketName)
		if err != nil {
			util.Logger.Errorf("query bucket error, err=%s", err.Error())
			return bundle.NewDeleteBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}
		if bucketInfo.Owner != signerAddress.String() {
			util.Logger.Errorf("signer is not the owner of the bucket, signer=%s, bucket=%s", signerAddress.String(), params.XBundleBucketName)
			return bundle.NewDeleteBundleBadRequest().WithPayload(types.InvalidSignatureErrorWithError(fmt.Errorf("signer is not the owner of the bucket")))
		}

		// delete bundle
		err = service.BundleSvc.DeleteBundle(params.XBundleBucketName, params.XBundleName)
		if err != nil {
			util.Logger.Errorf("delete bundle error, bucket=%s, bundle=%s, err=%s", params.XBundleBucketName, params.XBundleName, err.Error())
			return bundle.NewDeleteBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}

		return bundle.NewDeleteBundleOK()
	}
}

// HandleCreateBundle handles create bundle request
func HandleCreateBundle() func(params bundle.CreateBundleParams) middleware.Responder {
	return func(params bundle.CreateBundleParams) middleware.Responder {
		// validate headers
		signerAddress, merr := types.ValidateHeaders(params.HTTPRequest)
		if merr != nil {
			util.Logger.Errorf("sig check error, code=%d, msg=%s", merr.Code, merr.Message)
			return bundle.NewCreateBundleBadRequest().WithPayload(merr)
		}

		bucketInfo, err := service.BundleSvc.QueryBucketFromGnfd(params.XBundleBucketName)
		if err != nil {
			util.Logger.Errorf("query bucket error, err=%s", err.Error())
			return bundle.NewCreateBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}

		// check if the signer is the owner of the bucket
		if bucketInfo.Owner != signerAddress.String() {
			util.Logger.Errorf("signer is not the owner of the bucket, signer=%s, bucket=%s", signerAddress.String(), params.XBundleBucketName)
			return bundle.NewCreateBundleBadRequest().WithPayload(types.InvalidSignatureErrorWithError(fmt.Errorf("signer is not the owner of the bucket")))
		}

		// check bundle name prefix
		if service.IsAutoGeneratedBundleName(params.XBundleName) {
			util.Logger.Errorf("bundle name should not start with %s", service.BundleNamePrefix)
			return bundle.NewCreateBundleBadRequest().WithPayload(types.ErrorInvalidBundleName)
		}

		// validate bundle name
		if err := types.ValidateBundleName(params.XBundleName); err != nil {
			util.Logger.Errorf("invalid bundle name, err=%s", err.Message)
			return bundle.NewCreateBundleBadRequest().WithPayload(err)
		}

		// check the existence of the bundle in Greenfield
		_, err = service.BundleSvc.HeadObjectFromGnfd(params.XBundleBucketName, params.XBundleName)
		if err == nil {
			return bundle.NewCreateBundleBadRequest().WithPayload(types.ErrorObjectExist)
		}
		if !service.IsObjectNotFoundError(err) {
			return bundle.NewCreateBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}

		// create new bundle
		newBundle := database.Bundle{
			Owner:  signerAddress.String(),
			Bucket: params.XBundleBucketName,
			Name:   params.XBundleName,
		}

		// get bundler account for the user
		bundlerAccount, err := service.UserBundlerAccountSvc.GetOrCreateUserBundlerAccount(newBundle.Owner)
		if err != nil {
			util.Logger.Errorf("get bundler account for user error, user=%s, err=%s", newBundle.Owner, err.Error())
			return bundle.NewCreateBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}
		newBundle.BundlerAccount = bundlerAccount.BundlerAddress

		// create bundle
		_, err = service.BundleSvc.CreateBundle(newBundle)
		if err != nil {
			util.Logger.Errorf("create bundle error, bundle=%+v, err=%s", newBundle, err.Error())
			return bundle.NewCreateBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}

		return bundle.NewCreateBundleOK()
	}
}

// HandleFinalizeBundle handles finalize bundle request
func HandleFinalizeBundle() func(params bundle.FinalizeBundleParams) middleware.Responder {
	return func(params bundle.FinalizeBundleParams) middleware.Responder {
		// query bundle
		queriedBundle, err := service.BundleSvc.QueryBundle(params.XBundleBucketName, params.XBundleName)
		if err != nil {
			util.Logger.Errorf("query bundle error, bucket=%s, bundle=%s, err=%s", params.XBundleBucketName, params.XBundleName, err.Error())
			return bundle.NewFinalizeBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}

		// check signature
		signerAddress, err := types.VerifySignature(params.HTTPRequest)
		if err != nil {
			util.Logger.Errorf("sig check error, err=%s", err.Error())
			return bundle.NewFinalizeBundleBadRequest().WithPayload(types.ErrorInvalidSignature)
		}

		// check expiry timestamp
		if err := types.ValidateExpiryTimestamp(params.HTTPRequest); err != nil {
			util.Logger.Errorf("validate expiry timestamp error, err=%s", err.Error())
			return bundle.NewFinalizeBundleBadRequest().WithPayload(types.ErrorInvalidExpiryTimestamp)
		}

		// check owner
		if signerAddress.String() != queriedBundle.Owner {
			util.Logger.Errorf("invalid bundle owner, signer=%s, bundleOwner=%s", signerAddress.String(), queriedBundle.Owner)
			return bundle.NewFinalizeBundleBadRequest().WithPayload(types.ErrorInvalidBundleOwner)
		}

		// finalize bundle
		_, err = service.BundleSvc.FinalizeBundle(params.XBundleBucketName, params.XBundleName)
		if err != nil {
			util.Logger.Errorf("finalize bundle error, bucket=%s, bundle=%s, err=%s", params.XBundleBucketName, params.XBundleName, err.Error())
			return bundle.NewFinalizeBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}

		return bundle.NewFinalizeBundleOK()
	}
}

// HandleQueryBundle handles the query bundle request
func HandleQueryBundle() func(params bundle.QueryBundleParams) middleware.Responder {
	return func(params bundle.QueryBundleParams) middleware.Responder {
		bundleInfo, err := service.BundleSvc.QueryBundle(params.BucketName, params.BundleName)
		if err != nil {
			util.Logger.Errorf("query bundle error, bucket=%s, bundle=%s, err=%s", params.BucketName, params.BundleName, err.Error())
			return bundle.NewQueryBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
		}

		if bundleInfo.Id == 0 {
			return bundle.NewQueryBundleNotFound()
		}

		return bundle.NewQueryBundleOK().WithPayload(&models.QueryBundleResponse{
			BucketName:       bundleInfo.Bucket,
			BundleName:       bundleInfo.Name,
			Status:           int64(bundleInfo.Status),
			Files:            bundleInfo.Files,
			Size:             bundleInfo.Size,
			ErrorMessage:     bundleInfo.ErrMessage,
			CreatedTimestamp: bundleInfo.CreatedAt.Unix(),
		})
	}
}

// HandleQueryBundlingBundle handles the query bundling bundle request
func HandleQueryBundlingBundle() func(params bundle.QueryBundlingBundleParams) middleware.Responder {
	return func(params bundle.QueryBundlingBundleParams) middleware.Responder {
		bundleInfo, err := service.BundleSvc.GetBundlingBundle(params.BucketName)
		if err != nil {
			util.Logger.Errorf("query bundle error, bucket=%s, err=%s", params.BucketName, err.Error())
			return bundle.NewQueryBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
		}

		if bundleInfo.Id == 0 {
			return bundle.NewQueryBundlingBundleNotFound()
		}

		return bundle.NewQueryBundleOK().WithPayload(&models.QueryBundleResponse{
			BucketName:       bundleInfo.Bucket,
			BundleName:       bundleInfo.Name,
			Status:           int64(bundleInfo.Status),
			Files:            bundleInfo.Files,
			Size:             bundleInfo.Size,
			ErrorMessage:     bundleInfo.ErrMessage,
			CreatedTimestamp: bundleInfo.CreatedAt.Unix(),
		})
	}
}

func ValidateUploadBundleRequest(params bundle.UploadBundleParams) (common.Address, *models.Error) {
	// validate headers
	signerAddress, merr := types.ValidateHeaders(params.HTTPRequest)
	if merr != nil {
		util.Logger.Errorf("sig check error, code=%d, msg=%s", merr.Code, merr.Message)
		return common.Address{}, merr
	}

	bucketInfo, err := service.BundleSvc.QueryBucketFromGnfd(params.XBundleBucketName)
	if err != nil {
		util.Logger.Errorf("query bucket error, err=%s", err.Error())
		return common.Address{}, types.InternalErrorWithError(err)
	}

	// check if the signer is the owner of the bucket
	if bucketInfo.Owner != signerAddress.String() {
		util.Logger.Errorf("signer is not the owner of the bucket, signer=%s, bucket=%s", signerAddress.String(), params.XBundleBucketName)
		return common.Address{}, types.ErrorInvalidSignature
	}

	// check bundle name prefix
	if service.IsAutoGeneratedBundleName(params.XBundleName) {
		util.Logger.Errorf("bundle name should not start with %s", service.BundleNamePrefix)
		return common.Address{}, types.ErrorInvalidBundleName
	}

	// validate bundle name
	if err := types.ValidateBundleName(params.XBundleName); err != nil {
		util.Logger.Errorf("invalid bundle name, err=%s", err.Message)
		return common.Address{}, err
	}

	// check the existence of the bundle in Greenfield
	_, err = service.BundleSvc.HeadObjectFromGnfd(params.XBundleBucketName, params.XBundleName)
	if err == nil {
		return common.Address{}, types.ErrorObjectExist
	}
	if !service.IsObjectNotFoundError(err) {
		return common.Address{}, types.InternalErrorWithError(err)
	}

	return signerAddress, nil
}

func ValidateUploadedBundle(bdl *sdk.Bundle, rule database.BundleRule) *models.Error {
	if int64(bdl.GetBundleSize()) > rule.MaxSize {
		return types.ErrorBundleSizeExceedsLimit
	}

	metaData := bdl.GetBundleObjectsMeta()
	if int64(len(metaData)) > rule.MaxFiles {
		return types.ErrorBundleSizeExceedsLimit
	}

	// validate object name and size
	for _, meta := range metaData {
		if meta.Size > types.MaxFileSize {
			return types.ErrorBundleSizeExceedsLimit
		}

		err := types.ValidateObjectName(meta.Name)
		if err != nil {
			return err
		}
	}

	return nil
}

func HandleUploadBundle() func(params bundle.UploadBundleParams) middleware.Responder {
	return func(params bundle.UploadBundleParams) middleware.Responder {
		signerAddress, merr := ValidateUploadBundleRequest(params)
		if merr != nil {
			return bundle.NewUploadBundleBadRequest().WithPayload(merr)
		}

		// Create a temporary file
		tmpFile, err := os.CreateTemp(os.TempDir(), "tmp-bundle-")
		if err != nil {
			return bundle.NewUploadBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
		}
		defer os.Remove(tmpFile.Name())

		_, err = io.Copy(tmpFile, params.File)
		if err != nil {
			return bundle.NewUploadBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
		}
		defer tmpFile.Close()

		// Open the file as a bundle
		tmpBundle, err := sdk.NewBundleFromFile(tmpFile.Name())
		if err != nil {
			return bundle.NewUploadBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
		}
		defer tmpBundle.Close()

		// validate bundle
		bundleRule, err := service.BundleRuleSvc.QueryBundleRule(signerAddress.String(), params.XBundleBucketName)
		if err != nil {
			util.Logger.Errorf("query bundle rule error, err=%s", err.Error())
			return bundle.NewUploadBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
		}
		if err := ValidateUploadedBundle(tmpBundle, bundleRule); err != nil {
			return bundle.NewUploadBundleBadRequest().WithPayload(err)
		}

		// save bundle file first, then save records to database
		_, err = tmpFile.Seek(0, io.SeekStart)
		if err != nil {
			return bundle.NewUploadBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
		}
		_, _, err = service.ObjectSvc.StoreBundleFile(params.XBundleBucketName, params.XBundleName, tmpFile)
		if err != nil {
			return bundle.NewUploadBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
		}

		// get objects from bundle
		objects := make([]database.Object, 0, len(tmpBundle.GetBundleObjectsMeta()))
		for _, meta := range tmpBundle.GetBundleObjectsMeta() {
			tags, err := json.Marshal(meta.Tags)
			if err != nil {
				util.Logger.Errorf("marshal tags error, err=%s", err.Error())
				return bundle.NewUploadBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
			}
			newObject := database.Object{
				Bucket:         params.XBundleBucketName,
				BundleName:     params.XBundleName,
				ObjectName:     meta.Name,
				ContentType:    meta.ContentType,
				HashAlgo:       meta.HashAlgo,
				Hash:           meta.Hash,
				Owner:          signerAddress.String(),
				Tags:           string(tags),
				OffsetInBundle: int64(meta.Offset),
				Size:           int64(meta.Size),
			}
			objects = append(objects, newObject)
		}
		newBundle := database.Bundle{
			Owner:  signerAddress.String(),
			Bucket: params.XBundleBucketName,
			Name:   params.XBundleName,
			Files:  int64(len(objects)),
			Size:   int64(tmpBundle.GetBundleSize()),
		}

		// get bundler account for the user
		bundlerAccount, err := service.UserBundlerAccountSvc.GetOrCreateUserBundlerAccount(newBundle.Owner)
		if err != nil {
			util.Logger.Errorf("get bundler account for user error, user=%s, err=%s", newBundle.Owner, err.Error())
			return bundle.NewCreateBundleBadRequest().WithPayload(types.InternalErrorWithError(err))
		}
		newBundle.BundlerAccount = bundlerAccount.BundlerAddress

		// insert bundle and objects
		newBundle, err = service.BundleSvc.CreateFinalizedBundleWithObjects(newBundle, objects)
		if err != nil {
			util.Logger.Errorf("create finalized bundle with objects error, bundle=%+v, err=%s", newBundle, err.Error())
			return bundle.NewUploadBundleInternalServerError().WithPayload(types.InternalErrorWithError(err))
		}

		return bundle.NewUploadBundleOK()
	}
}
